let PwdWriteBackAppRoles = dynamic(['PasswordWriteback.RefreshClient.All','PasswordWriteback.RegisterClientVersion.All']);
let SyncApiApproles = dynamic(['ADSynchronization.ReadWrite.All']);
let EntraConnectAppIdentities = OAuthAppInfo
| mv-expand Permission = parse_json(Permissions)
| where (parse_json(Permission)["TargetAppDisplayName"] == 'Microsoft Entra AD Synchronization Service' and parse_json(Permission)["PermissionValue"] has_any (SyncApiApproles)) or 
        (parse_json(Permission)["TargetAppDisplayName"] == 'Microsoft password reset service' and parse_json(Permission)["PermissionValue"] has_any (PwdWriteBackAppRoles))
| summarize Permissions = make_set(Permission) by ServicePrincipalId, OAuthAppId, AppName, AppOwnerTenantId, AppStatus, AddedOnTime, LastModifiedTime;
AADServicePrincipalSignInLogs
| where ResultType == "0"
| where ServicePrincipalId in (EntraConnectAppIdentities)
// Enrichment to EntraIdSpnSignInEvents to get ReportId (required field for detection) and RequestId (for hunting in activity logs)
| join kind = inner ( EntraIdSpnSignInEvents ) on CorrelationId
| project Timestamp = CreatedDateTime, IPAddress, ClientCredentialType, FederatedCredentialId, ServicePrincipalCredentialKeyId, ServicePrincipalCredentialThumbprint, UserAgent, ResourceDisplayName, ResultType, SessionId, UniqueTokenIdentifier, Location, ReportId, RequestId
| extend MaliciousCredential = case(
                isnotempty(FederatedCredentialId)
            , "App Authentication is using Federated Credentials instead of a certificate",
                ClientCredentialType != "clientAssertion"
            , "App Authentication is using credentials instead of a certificate",
            ""
            ) 
| where isnotempty(MaliciousCredential)